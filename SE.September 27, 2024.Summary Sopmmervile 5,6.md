![Cover Image of chrome-extension://hldjnlbobkdkghfidgoecgmklcemanhm/pdf/web/viewer.html?file=file%3A%2F%2F%2FC%3A%2FUsers%2Fthead%2FDocuments%2FUACH%2FSeventh%2520Semester%2FSoftware%2520Engineering%2Fingdelsoftwarelibro9_compressed.pdf](https://web-highlights.com/images/fallback-image.png?auto=format&w=600&fm=auto)
  
# Ingenieria de Software - ingdelsoftwarelibro9_compressed.pdf


üåê chrome-extension://hldjnlbobkdkghfidgoecgmklcemanhm/pdf/web/viewer.html?file=file%3A%2F%2F%2FC%3A%2FUsers%2Fthead%2FDocuments%2FUACH%2FSeventh%2520Semester%2FSoftware%2520Engineering%2Fingdelsoftwarelibro9_compressed.pdf
üîó https://app.web-highlights.com/page/66f5f0972f2aaf23ca0ee9aa

**Tags**: -

**Highlights & Notes**

> ingenier√≠a de requerimientos basada en un modelo, procesos de software
para desarrollo basado en un modelo, y pruebas basadas en un modelo son parte de MDE,
pero no, en este momento, de la MDA

> Esta visi√≥n de un sistema es adecuado particularmente para sistema en tiempo
real.

> l dise√±o arquitect√≥nico como un conjunto de decisiones a tomar

> los patrones como una forma de presentar, compartir y reutilizar el conoci-
miento sobre los sistemas de software se usa ahora ampliamente.

> No siempre necesitar√° apegarse rigurosamente a los detalles de una notaci√≥n.

> El mode-
lado de interacci√≥n del usuario es importante, pues ayuda a identificar los requerimientos
del usuario. El modelado de la interacci√≥n sistema a sistema destaca los problemas de
comunicaci√≥n que se lleguen a presentar. El modelado de interacci√≥n de componentes
ayuda a entender si es probable que una estructura de un sistema propuesto obtenga el
rendimiento y la confiabilidad requeridos por el sistema

> ra
la mayor√≠a de los sistemas, no vale la pena desarrollar una descripci√≥n arquitect√≥nica
detallada desde estas cuatro perspectivas. Uno debe desarrollar las vistas que sean √∫tiles
para la comunicaci√≥n sin preocuparse si la documentaci√≥n arquitect√≥nica est√° completa
o no. Sin embargo, una excepci√≥n es al desarrollar sistemas cr√≠ticos, cuando es necesario
realizar un an√°lisis de confiabilidad detallado del sistema. Tal vez se deba convencer a
reguladores externos de que el sistema se hizo conforme a sus regulaciones y, en conse-
cuencia, puede requerirse una documentaci√≥n arquitect√≥nica completa

> patr√≥n
de repositorio (figura 6.8), describe c√≥mo comparte datos un conjunto de componentes
en interacci√≥n.

> Cada paso de
procesamiento se implementa como un transformador.

> Los datos fluyen
de uno a otro y se transforman conforme se desplazan a trav√©s de la secuencia

> Un caso de uso puede
tomarse como un simple escenario que describa lo que espera el usuario de un sistema.

> res formas en que los
modelos gr√°ficos se emplean con frecuencia:
1. Como medio para facilitar la discusi√≥n sobre un sistema existente o propuesto.
2. Como una forma de documentar un sistema existente.
3. Como una descripci√≥n detallada del sistema que sirve para generar una implementa-
ci√≥n de sistema

> arquitecturas de dos
tipos de aplicaci√≥n:
1. Aplicaciones de procesamiento de transacci√≥n Este tipo de aplicaciones son aplicacio-
nes centradas en bases de datos, que procesan los requerimientos del usuario mediante
la informaci√≥n y actualizan √©sta en una base de datos. Se trata del tipo m√°s com√∫n de
sistemas empresariales interactivos. Se organizan de tal forma que las acciones
del usuario no pueden interferir unas con otras y se mantiene la integridad de la base

> n una arquitectura
de compilador, la tabla de s√≠mbolos es un repositorio para datos compartidos. Las fases de
an√°lisis l√©xico, sint√°ctico y sem√°ntico se organizan de manera secuencial, como se mues-
tra en la figura 6.19, y se comunican a trav√©s de la tabla de s√≠mbolos compartida.

> s necesario elegir
la estructura m√°s adecuada, como cliente-servidor o estructura en capas, que le permita
satisfacer los requerimientos del sistema. Para descomponer las unidades del sistema
estructural, usted opta por la estrategia de separar los componentes en subcomponen-
tes. Los enfoques que pueden usarse permiten la implementaci√≥n de diferentes tipos de
arquitectura. Finalmente, en el proceso de modelado de control, se toman decisiones
sobre c√≥mo se controla la ejecuci√≥n de componentes

> erspectiva estructural, donde se modelen la organizaci√≥n de un sistema o la
estructura de datos que procese el sistema

> Krutchen (1995), en
su bien conocido modelo de vista 4+1 de la arquitectura de software, sugiere que deben
existir cuatro vistas arquitect√≥nicas fundamentales, que se relacionan usando casos de
uso o escenarios. Las vistas que √©l sugiere son:
1. Una vista l√≥gica, que indique las abstracciones clave en el sistema como objetos o
clases de objeto. En este tipo de vista se tienen que relacionar los requerimientos del
sistema con entidades.

> buscar posibles traslapes en la funcionalidad con los sistemas existentes y determi-
nar d√≥nde tiene que implementarse nueva funcionalidad. Estas decisiones deben hacerse
oportunamente durante el proceso, para limitar los costos del sistema, as√≠ como el tiempo
necesario para comprender los requerimientos y el dise√±o del sistema

> el dise√±o arquitect√≥nico es la
primera etapa en el proceso de dise√±o del software. Es el enlace crucial entre el dise√±o y
la ingenier√≠a de requerimientos, ya que identifica los principales componentes estructura-
les en un sistema y la relaci√≥n entre ellos. La salida del proceso de dise√±o arquitect√≥nico
consiste en un modelo arquitect√≥nico que describe la forma en que se organiza el sistema
como un conjunto de componentes en comunicaci√≥n

> El patr√≥n de arquitectura en
capas es otra forma de lograr separaci√≥n e independencia

> La descripci√≥n del patr√≥n estilizado incluye el nombre del patr√≥n, una breve des-
cripci√≥n (con un modelo gr√°fico asociado) y un ejemplo del tipo de sistema donde se usa
el patr√≥n (de nuevo, quiz√° con un modelo gr√°fico). Tambi√©n debe incluir informaci√≥n
sobre cu√°ndo hay que usar el patr√≥n, as√≠ como sobre sus ventajas y desventajas. E

> uando los modelos se usan como
documentaci√≥n, no tienen que estar completos, pues quiz√°s usted s√≥lo desee desarro-
llar modelos para algunas partes de un sistema. Sin embargo, estos modelos deben ser
correctos: tienen que usar adecuadamente la notaci√≥n y ser una descripci√≥n precisa del
sistema.

> Es posible que los datos se pro-
cesen por cada transformador √≠tem por √≠tem o en un solo lote.

> El UML proporciona un tipo especial
de asociaci√≥n entre clases llamado agregaci√≥n, que significa que un objeto (el todo) se
compone de otros objetos (las partes). Para mostrarlo, se usa un trazo en forma de dia-
mante, junto con la clase que representa el todo.

> A partir de un modelo independiente
de plataforma de alto nivel, es posible, en principio, generar un programa funcional sin
intervenci√≥n manual

> os diagramas de actividad inten-
tan mostrar las actividades que incluyen un proceso de sistema, as√≠ como el flujo de
control de una actividad a otra. El inicio de un proceso se indica con un c√≠rculo lleno;
el fin, mediante un c√≠rculo lleno dentro de otro c√≠rculo. Los rect√°ngulos con esquinas
redondeadas representan actividades, esto es, los subprocesos espec√≠ficos que hay que
realizar. Puede incluir objetos en los gr√°ficos de actividad.

> Cuando las transformaciones son
secuenciales, con datos procesados en lotes, este modelo arquitect√≥nico de tuber√≠a y fil-
tro se convierte en un modelo secuencial en lote, una arquitectura com√∫n para sistemas
de procesamiento de datos

> perspectiva externa, donde se modelen el contexto o entorno del sistema

> perspectiva de interacci√≥n, donde se modele la interacci√≥n entre un sistema y su
entorno, o entre los componentes de un sistema

> aplicaciones en las que un componente genere datos y otro los use. L

> es un modelo de la organizaci√≥n en tiempo de operaci√≥n de un sistema, donde las
transformaciones funcionales procesan sus entradas y producen salidas

> el patr√≥n tuber√≠a y filtro

> entajas de dise√±ar y documentar de
manera expl√≠cita la arquitectura de software:
1. Comunicaci√≥n con los participantes La arquitectura es una presentaci√≥n de alto
nivel del sistema, que puede usarse como un enfoque para la discusi√≥n de un amplio
n√∫mero de participantes.
2. An√°lisis del sistema En una etapa temprana en el desarrollo del sistema, aclarar la
arquitectura del sistema requiere cierto an√°lisis. Las decisiones de dise√±o arquitect√≥-
nico tienen un efecto profundo sobre si el sistema puede o no cubrir requerimientos
cr√≠ticos como rendimiento, fiabilidad y mantenibilidad.
3. Reutilizaci√≥n a gran escala Un modelo de una arquitectura de sistema es una des-
cripci√≥n corta y manejable de c√≥mo se organiza un sistema y c√≥mo interoperan sus
componentes. Por lo general, la arquitectura del sistema es la misma para sistemas
con requerimientos similares y, por lo tanto, puede soportar reutilizaci√≥n de software
a gran escala.

> perspectiva de comportamiento, donde se modele el comportamiento din√°mico
del sistema y c√≥mo responde ante ciertos eventos

> se crean cuando se discute y dise√±a la arqui-
tectura del sistema. El dise√±o arquitect√≥nico es un tema particularmente importante en la
ingenier√≠a de software, y los diagramas UML de componente, de paquete y de implemen-
taci√≥n se utilizan cuando se presentan modelos arquitect√≥nicos.

> Es posible hacer enunciados generales que se
apliquen a todos los miembros de la clase

> Cuando se desarrolla un modelo, la primera etapa con frecuencia implica buscar en
el mundo, identificar los objetos esenciales y representarlos como clases. La forma m√°s
sencilla de hacer esto es escribir el nombre de la clase en un recuadro. Tambi√©n puede
anotar la existencia de una asociaci√≥n dibujando simplemente una l√≠nea entre las clases.
An√°lisis de requerimientos orientado a objetos
En el an√°lisis de requerimientos orientado a objetos, se modelan entidades del mundo real usando clases
de objetos. Usted puede crear diferentes tipos de modelos de objetos, que muestren c√≥mo se relacionan
mutuamente las clases de objetos, c√≥mo se agregan objetos para formar otros objetos, c√≥mo interact√∫an los
objetos entre s√≠, etc√©tera. Cada uno de √©stos presenta informaci√≥n √∫nica acerca del sistema que se especifica.
http://www.SoftwareEngineering-9.com/Web/OORA/

> el sistema Unix original, donde era posible
vincular procesos empleando ‚Äútuber√≠as‚Äù

> La notaci√≥n con figura humana se desarroll√≥ original-
mente para cubrir la interacci√≥n entre individuos, pero tambi√©n se usa ahora para repre-
sentar otros sistemas externos y el hardware. De manera formal, los diagramas de caso de
uso deben emplear l√≠neas sin flechas; las flechas en el UML indican la direcci√≥n del flujo
de mensajes. Evidentemente, en un caso de uso los mensajes pasan en ambas direcciones

> Cada recuadro en el diagrama representa un com-
ponente. Los recuadros dentro de recuadros indican que el componente se dividi√≥ en
subcomponentes. Las flechas significan que los datos y/o se√±ales de control pasan de
un componente a otro en la direcci√≥n de las flechas.

> onforme se desarrolla una implementaci√≥n, por lo general
se necesitan definir los objetos de implementaci√≥n adicionales que se usan para dar la
funcionalidad requerida del sistema. Aqu√≠, el enfoque est√° sobre el modelado de objetos
del mundo real, como parte de los requerimientos o los primeros procesos de dise√±o del
software.

> a generalizaci√≥n se muestra como una flecha que apunta
hacia la clase m√°s general.

> Sin embargo, se considera que la MDE tiene un √°mbito m√°s
amplio que la MDA. Como se estudia m√°s adelante en esta secci√≥n, la MDA se enfoca en
las etapas de dise√±o e implementaci√≥n del desarrollo de software, mientras que la MDE
se interesa por todos los aspectos del proceso de ingenier√≠a de software.

> Una forma de hacer esto es mediante la noci√≥n de un superestado
que encapsule algunos estados separados. Este superestado se parece a un solo estado en
un modelo de nivel superior, pero entonces se expande para mostrar m√°s detalles en un
diagrama separad

> soporta el desarrollo incremental de sistemas. Conforme se
desarrolla una capa, algunos de los servicios proporcionados por esta capa deben quedar
a disposici√≥n de los usuarios. La arquitectura tambi√©n es cambiable y port√°til. En tanto
su interfaz no var√≠e, una capa puede sustituirse por otra equivalente. M√°s a√∫n, cuando
las interfaces de capa cambian o se agregan nuevas facilidades a una capa, s√≥lo resulta
afectada la capa adyacente

> vista conceptual. Esta √∫ltima es una vista abstracta del sistema que
puede ser la base para descomponer los requerimientos de alto nivel en especificaciones
m√°s detalladas, ayudar a los ingenieros a tomar decisiones sobre componentes que pue-
dan reutilizarse, y representar una l√≠nea de producto

> Un patr√≥n arquitect√≥nico es una descripci√≥n de una organizaci√≥n del
sistema

> Se usa el t√©rmino ‚Äúfiltro‚Äù porque una transformaci√≥n ‚Äúfiltra‚Äù los
datos que puede procesar de su secuencia de datos de entrada

> la funcionalidad del sistema est√° organizada en capas separadas, y cada
una se apoya s√≥lo en las facilidades y los servicios ofrecidos por la capa inmediatamente
debajo de ella

> un patr√≥n arquitect√≥nico debe describir una organizaci√≥n de sistema que
ha tenido √©xito en sistemas previos. Debe incluir informaci√≥n sobre cu√°ndo es y cu√°ndo
no es adecuado usar dicho patr√≥n, as√≠ como sobre las fortalezas y debilidades del patr√≥n

> Los patrones arquitect√≥nicos captan la esencia de una arquitectura que se us√≥
en diferentes sistemas de software

> . Sistemas de procesamiento de lenguaje Son sistemas en los que las intenciones del
usuario se expresan en un lenguaje formal (como Java). El sistema de procesamiento
de lenguaje elabora este lenguaje en un formato interno y despu√©s interpreta dicha
representaci√≥n interna. Los sistemas de procesamiento de lenguaje mejor conocidos
son los compiladores, que traducen los programas en lenguaje de alto nivel dentro de
un c√≥digo de m√°quina. Sin embargo, los sistemas de procesamiento de lenguaje se usan
tambi√©n en la interpretaci√≥n de lenguajes de comandos para bases de datos y sistemas
de informaci√≥n, as√≠ como de lenguajes de marcado como XML

> 1. Diagramas de actividad, que muestran las actividades incluidas en un proceso o en
el procesamiento de datos.
2. Diagramas de caso de uso, que exponen las interacciones entre un sistema y su
entorno.
3. Diagramas de secuencias, que muestran las interacciones entre los actores y el sis-
tema, y entre los componentes del sistema.
4. Diagramas de clase, que revelan las clases de objeto en el sistema y las asociaciones
entre estas clases.
5. Diagramas de estado, que explican c√≥mo reacciona el sistema frente a eventos inter-
nos y externos.

> La definici√≥n de frontera de un sistema no es un juicio libre de valor. Las preocupa-
ciones sociales y organizacionales pueden significar que la posici√≥n de la frontera de un
sistema se determine considerando factores no t√©cnicos. Por ejemplo, una frontera
de sistema puede colocarse deliberadamente, de modo que todo el proceso de an√°lisis se
realice en un sitio; puede elegirse de forma que sea innecesario consultar a un adminis-
trador particularmente dif√≠cil; puede situarse de manera que el costo del sistema aumente
y la divisi√≥n de desarrollo del sistema deba, por lo tanto, expandirse al dise√±o y la imple-
mentaci√≥n del sistema

> Los modelos de contexto, por lo general, muestran que el entorno incluye varios
sistemas automatizados. Sin embargo, no presentan los tipos de relaciones entre los sis-
temas en el entorno y el sistema que se especifica. Los sistemas externos generan datos
para el sistema o consumen datos del sistema. Pueden compartir datos con el sistema,
conectarse directamente, a trav√©s de una red, o no conectarse en absoluto. Pueden estar
f√≠sicamente juntos o ubicados en edificios separados. Todas estas relaciones llegan a
afectar los requerimientos y el dise√±o del sistema a definir, por lo que deben tomarse en
cuenta.
Por consiguiente, los modelos de contexto simples se usan junto con otros modelos,
como los modelos de proceso empresarial. √âstos describen procesos humanos y automa-
tizados que se usan en sistemas particulares de software

> En un diagrama de actividad UML, las flechas representan el flujo de trabajo de una acti-
vidad a otra. Una barra s√≥lida se emplea para indicar coordinaci√≥n de actividades. Cuando
el flujo de m√°s de una actividad se dirige a una barra s√≥lida, entonces todas esas actividades
deben completarse antes del posible avance. Cuando el flujo de una barra s√≥lida conduzca
a algunas actividades, √©stas pueden ejecutarse en forma paralela.

> 1. Modelado de caso de uso, que se utiliza principalmente para modelar interacciones
entre un sistema y actores externos (usuarios u otros sistemas).
2. Diagramas de secuencia, que se emplean para modelar interacciones entre compo-
nentes del sistema, aunque tambi√©n pueden incluirse agentes externos.

> Cada caso de uso representa una tarea discreta que implica interacci√≥n externa con
un sistema. En su forma m√°s simple, un caso de uso se muestra como una elipse, con los
actores que intervienen en el caso de uso representados como figuras humanas

> Los diagramas de secuencia en el UML se usan principalmente para modelar las interaccio-
nes entre los actores y los objetos en un sistema, as√≠ como las interacciones entre los obje-
tos en s√≠. El UML tiene una amplia sintaxis para diagramas de secuencia, lo cual permite
muchos tipos diferentes de interacci√≥n a modelar.

> Como sugiere el nombre, un diagrama de secuencia muestra la sucesi√≥n de interaccio-
nes que ocurre durante un caso de uso particular o una instancia de caso de uso.

> Los objetos y actores que intervienen se mencionan a lo largo de la parte superior del
diagrama, con una l√≠nea punteada que se dibuja verticalmente a partir de √©stos. Las inte-
racciones entre los objetos se indican con flechas dirigidas. El rect√°ngulo sobre las l√≠neas
punteadas indica la l√≠nea de vida del objeto tratado (es decir, el tiempo que la instancia
del objeto est√° involucrada en la computaci√≥n). La secuencia de interacciones se lee de
arriba abajo. Las anotaciones sobre las flechas se√±alan las llamadas a los objetos, sus
par√°metros y los valores que regresan. En este ejemplo, tambi√©n se muestra la notaci√≥n
empleada para exponer alternativas. Un recuadro marcado con ‚Äúalt‚Äù se usa con las condi-
ciones indicadas entre corchetes.

> A menos que use diagramas de secuencia para generaci√≥n de c√≥digo o documen-
taci√≥n detallada, en dichos diagramas no tiene que incluir todas las interacciones. Si
desarrolla modelos iniciales de sistema en el proceso de desarrollo para apoyar la ingenie-
r√≠a de requerimientos y el dise√±o de alto nivel, habr√° muchas interacciones que dependan
de decisiones de implementaci√≥n.

> Los modelos estructurales de software muestran la organizaci√≥n de un sistema, en t√©r-
minos de los componentes que constituyen dicho sistema y sus relaciones. Los modelos
estructurales son modelos est√°ticos, que muestran la estructura del dise√±o del sistema, o
modelos din√°micos, que revelan la organizaci√≥n del sistema cuando se ejecuta. No son lo
mismo: la organizaci√≥n din√°mica de un sistema como un conjunto de hilos en interacci√≥n
tiende a ser muy diferente de un modelo est√°tico de componentes del sistema

> Los diagramas de clase pueden usarse cuando se desarrolla un modelo de sistema orien-
tado a objetos para mostrar las clases en un sistema y las asociaciones entre dichas clases.
De manera holgada, una clase de objeto se considera como una definici√≥n general de un
tipo de objeto del sistema. Una asociaci√≥n es un v√≠nculo entre clases, que indica que hay
una relaci√≥n entre dicha clases. En consecuencia, cada clase puede tener alg√∫n conoci-
miento de esta clase asociada.

> En este nivel de detalle, los diagramas de clase parecen modelos sem√°nticos de datos.
Los modelos sem√°nticos de datos se usan en el dise√±o de bases de datos. Muestran las
entidades de datos, sus atributos asociados y las relaciones entre dichas entidades. Es

> Cuando se muestran las asociaciones entre clases, es conveniente representar dichas
clases en la forma m√°s sencilla posible. Para definirlas con m√°s detalle, agregue infor-
maci√≥n sobre sus atributos (las caracter√≠sticas de un objeto) y operaciones (aquello que
se puede solicitar de un objeto)

> 1. El nombre de la clase de objeto est√° en la secci√≥n superior.
2. Los atributos de clase est√°n en la secci√≥n media. Esto debe incluir los nombres del
atributo y, opcionalmente, sus tipos.
3. Las operaciones (llamadas m√©todos en Java y en otros lenguajes de programaci√≥n
OO) asociadas con la clase de objeto est√°n en la secci√≥n inferior del rect√°ngulo.

> La generalizaci√≥n es una t√©cnica cotidiana que se usa para gestionar la complejidad.
En vez de aprender las caracter√≠sticas detalladas de cada entidad que se experimenta,
dichas entidades se colocan en clases m√°s generales

> En el modelado de sistemas, con frecuencia es √∫til examinar las clases en un sistema,
con la finalidad de ver si hay √°mbito para la generalizaci√≥n. Esto significa que la infor-
maci√≥n com√∫n se mantendr√° solamente en un lugar. √âsta es una buena pr√°ctica de dise√±o,
pues significa que, si se proponen cambios, entonces no se tiene que buscar en todas las
clases en el sistema, para observar si se ven afectadas por el cambio. En los lenguajes
orientados a objetos, como Java, la generalizaci√≥n se implementa usando los mecanis-
mos de herencia de clase construidos en el lenguaje

> En una generalizaci√≥n, los atributos y las operaciones asociados con las clases de
nivel superior tambi√©n se asocian con las clases de nivel inferior. En esencia, las cla-
ses de nivel inferior son subclases que heredan los atributos y las operaciones de sus
superclases. Entonces dichas clases de nivel inferior agregan atributos y operaciones
m√°s espec√≠ficos.

> Los modelos de comportamiento son modelos din√°micos del sistema conforme se eje-
cutan. En ellos se muestra lo que sucede o lo que se supone que pasa cuando un sistema
responde ante un est√≠mulo de su entorno. Tales est√≠mulos son de dos tipos:
1. Datos Algunos datos que llegan se procesan por el sistema.
2. Eventos Algunos eventos activan el procesamiento del sistema. Los eventos pueden
tener datos asociados, pero esto no es siempre el caso.

> Los modelos dirigidos por datos muestran la secuencia de acciones involucradas en
el procesamiento de datos de entrada, as√≠ como la generaci√≥n de una salida asociada.
Son particularmente √∫tiles durante el an√°lisis de requerimientos, pues sirven para mostrar
procesamiento ‚Äúextremo a extremo‚Äù en un sistema. Esto es, exhiben toda la secuencia de
acciones que ocurren desde una entrada a procesar hasta la salida correspondiente, que es
la respuesta del sistema

> El UML no soporta diagramas de flujo de datos, puesto que originalmente se propusie-
ron y usaron para modelar el procesamiento de datos. La raz√≥n para esto es que los DFD
se enfocan en funciones del sistema y no reconocen objetos del sistema. S

> El modelado dirigido por un evento muestra c√≥mo responde un sistema a eventos exter-
nos e internos. Se basa en la suposici√≥n de que un sistema tiene un n√∫mero finito de
estados y que los eventos (est√≠mulos) pueden causar una transici√≥n de un estado a otro.

> El UML soporta modelado basado en eventos usando diagramas de estado, que se fun-
damentaron en gr√°ficos de estado (Harel, 1987, 1988). Los diagramas de estado muestran
estados y eventos del sistema que causan transiciones de un estado a otro

> En los diagramas de estado UML, los rect√°ngulos redondeados representan estados
del sistema. Pueden incluir una breve descripci√≥n (despu√©s de ‚Äúdo‚Äù) de las acciones que
se tomar√°n en dicho estado. Las flechas etiquetadas representan est√≠mulos que fuerzan
una transici√≥n de un estado a otro. Puede indicar los estados inicial y final usando c√≠rcu-
los rellenos, como en los diagramas de actividad

> La notaci√≥n UML permite indicar la actividad que ocurre en un estado. En una especifi-
caci√≥n detallada del sistema, hay que proporcionar m√°s detalle tanto de los est√≠mulos como
de los estados del sistema

> El problema con el modelado basado en el estado es que el n√∫mero de posibles estados
se incrementa r√°pidamente

> La ingenier√≠a dirigida por modelo (MDE, por las siglas de Model-Driven Engineering) es
un enfoque al desarrollo de software donde los modelos, y no los programas, son las sali-
das principales del proceso de desarrollo (

> La ingenier√≠a basada en modelo permite a los ingenieros pen-
sar sobre sistemas en un nivel de abstracci√≥n elevado, sin ocuparse por los deta-
lles de su implementaci√≥n. Esto reduce la probabilidad de errores, acelera el dise√±o
y el proceso de implementaci√≥n, y permite la creaci√≥n de modelos de aplicaci√≥n
reutilizables, independientes de la plataforma de aplicaci√≥n. A

> no siempre se sigue que las abstracciones que soporta el modelo son las abstrac-
ciones correctas para la implementaci√≥n. De este modo, es posible crear modelos
de dise√±o informal, pero siendo as√≠, el sistema se implementa usando un paquete
configurable comercial

> La arquitectura dirigida por modelo (Kleppe et al., 2003; Mellor et al., 2004; Stahl y
Voelter, 2006) es un enfoque orientado a un modelos para el dise√±o y la implementaci√≥n
de software, que usa un subconjunto de modelos UML para describir un sistem

> El m√©todo de MDA recomienda la producci√≥n de tres tipos de modelo de sistema
abstracto:
1. Un modelo independiente de computaci√≥n (CIM) que modela las importantes abs-
tracciones de dominio usadas en el sistema

> 2. Un modelo independiente de plataforma (PIM) que modele la operaci√≥n del sistema
sin referencia a su implementaci√≥n. El PIM se describe usualmente mediante mode-
los UML que muestran la estructura est√°tica del sistema y c√≥mo responde a eventos
externos e internos

> 3. Modelos espec√≠ficos de plataforma (PSM) que son transformaciones del modelo
independiente de plataforma con un PSM separado para cada plataforma de apli-
caci√≥n. En principio, puede haber capas de PSM, y cada una agrega cierto detalle
espec√≠fico de la plataforma. De este modo, el PSM de primer nivel podr√≠a ser espec√≠fi-
co de ‚Äúmiddleware‚Äù, pero independiente de la base de datos. Cuando se elige una base
de datos espec√≠fica, podr√≠a generarse entonces un PSM espec√≠fico de base de datos

> La noci√≥n fundamental detr√°s de la ingenier√≠a dirigida por modelo es que debe ser posible
la transformaci√≥n completamente automatizada de modelos a c√≥digo. Para lograr esto,
usted tiene que ser capaz de construir modelos gr√°ficos, cuya sem√°ntica est√© bien defi-
nida. Tambi√©n necesita una forma de agregar a los modelos gr√°ficos, informaci√≥n sobre
la forma en que se implementan las operaciones definidas en el modelo.

> El dise√±o arquitect√≥nico se interesa por entender c√≥mo debe organizarse un sistema y
c√≥mo tiene que dise√±arse la estructura global de ese sistema.

> En la pr√°ctica, hay un significativo traslape entre los procesos de ingenier√≠a de reque-
rimientos y el dise√±o arquitect√≥nico. De manera ideal, una especificaci√≥n de sistema no
debe incluir cierta informaci√≥n de dise√±o. Esto no es realista, excepto para sistemas muy
peque√±os. La descomposici√≥n arquitect√≥nica es por lo general necesaria para estructurar
y organizar la especificaci√≥n. Por lo tanto, como parte del proceso de ingenier√≠a de reque-
rimientos, usted podr√≠a proponer una arquitectura de sistema abstracta donde se asocien
grupos de funciones de sistemas o caracter√≠sticas con componentes o subsistemas a gran
escala. Luego, puede usar esta descomposici√≥n para discutir con los participantes sobre
los requerimientos y las caracter√≠sticas del sistema

> 1. La arquitectura en peque√±o se interesa por la arquitectura de programas individua-
les. En este nivel, uno se preocupa por la forma en que el programa individual se
separa en componentes. Este cap√≠tulo se centra principalmente en arquitecturas de
programa.
2. La arquitectura en grande se interesa por la arquitectura de sistemas empresaria-
les complejos que incluyen otros sistemas, programas y componentes de programa.

> Las arquitecturas de sistemas se modelan con frecuencia usando diagramas de blo-
ques simples

> hay dos formas en que se utiliza un modelo arquitect√≥nico de un programa:
1. Como una forma de facilitar la discusi√≥n acerca del dise√±o del sistema

> 2. Como una forma de documentar una arquitectura que se haya dise√±ado

> El dise√±o arquitect√≥nico es un proceso creativo en el cual se dise√±a una organizaci√≥n
del sistema que cubrir√° los requerimientos funcionales y no funcionales de √©ste.

> 1. ¬øExiste alguna arquitectura de aplicaci√≥n gen√©rica que act√∫e como plantilla para el
sistema que se est√° dise√±ando?
2. ¬øC√≥mo se distribuir√° el sistema a trav√©s de algunos n√∫cleos o procesadores?
3. ¬øQu√© patrones o estilos arquitect√≥nicos pueden usarse?
4. ¬øCu√°l ser√° el enfoque fundamental usado para estructurar el sistema?
5. ¬øC√≥mo los componentes estructurales en el sistema se separar√°n en subcomponentes?
6. ¬øQu√© estrategia se usar√° para controlar la operaci√≥n de los componentes en el
sistema?
7. ¬øCu√°l organizaci√≥n arquitect√≥nica es mejor para entregar los requerimientos no fun-
cionales del sistema?
8. ¬øC√≥mo se evaluar√° el dise√±o arquitect√≥nico?
9. ¬øC√≥mo se documentar√° la arquitectura del sistema?

> 1. Rendimiento Si el rendimiento es un requerimiento cr√≠tico, la arquitectura debe
dise√±arse para localizar operaciones cr√≠ticas dentro de un peque√±o n√∫mero de com-
ponentes, con todos estos componentes desplegados en la misma computadora en vez
de distribuirlos por la red

> 2. Seguridad Si la seguridad es un requerimiento cr√≠tico, ser√° necesario usar una
estructura en capas para la arquitectura, con los activos m√°s cr√≠ticos protegidos en
las capas m√°s internas, y con un alto nivel de validaci√≥n de seguridad aplicado a
dichas capas.

> 3. Protecci√≥n Si la protecci√≥n es un requerimiento cr√≠tico, la arquitectura debe dise-
√±arse de modo que las operaciones relacionadas con la protecci√≥n se ubiquen en alg√∫n
componente individual o en un peque√±o n√∫mero de componentes.

> 4. Disponibilidad Si la disponibilidad es un requerimiento cr√≠tico, la arquitectura tiene
que dise√±arse para incluir componentes redundantes de manera que sea posible sus-
tituir y actualizar componentes sin detener el sistema.

> 5. Mantenibilidad Si la mantenibilidad es un requerimiento cr√≠tico, la arquitectura
del sistema debe dise√±arse usando componentes autocontenidos de grano fino q

> 2. Una vista de proceso, que muestre c√≥mo, en el tiempo de operaci√≥n, el sistema est√°
compuesto de procesos en interacci√≥n.

> 3. Una vista de desarrollo, que muestre c√≥mo el software est√° descompuesto para
su desarrollo, esto es, indica la descomposici√≥n del software en elementos que se
implementen mediante un solo desarrollador o equipo de desarrollo.

> 4. Una vista f√≠sica, que exponga el hardware del sistema y c√≥mo los componentes de
software se distribuyen a trav√©s de los procesadores en el sistema.

> Un patr√≥n arquitect√≥nico se puede considerar como una descripci√≥n abstracta estili-
zada de buena pr√°ctica, que se ensay√≥ y puso a prueba en diferentes sistemas y entornos

> Las nociones de separaci√≥n e independencia son fundamentales para el dise√±o arquitec-
t√≥nico porque permiten localizar cambios.

> La mayor√≠a de los sistemas que usan grandes cantidades de datos se organizan sobre
una base de datos o un repositorio compartido.

> Un sistema que sigue el patr√≥n cliente-servidor se organiza como un conjunto de ser-
vicios y servidores asociados, y de clientes que acceden y usan los servicios. Los princi-
pales componentes de este modelo son:
1. Un conjunto de servidores que ofrecen servicios a otros componentes.

> 2. Un conjunto de clientes que solicitan los servicios que ofrecen los servidores

> 3. Una red que permite a los clientes acceder a dichos servicios

> Las arquitecturas cliente-servidor se consideran a menudo como arquitecturas de sis-
temas distribuidos; sin embargo, el modelo l√≥gico de servicios independientes que opera
en servidores separados puede implementarse en una sola computadora.

> Es posible que los clientes deban conocer los nombres de los servidores disponibles,
as√≠ como los servicios que proporcionan. Sin embargo, los servidores no necesitan cono-
cer la identidad de los clientes o cu√°ntos clientes acceden a sus servicios. L

> Los sistemas interactivos son dif√≠ciles de escribir con el modelo tuber√≠a y filtro, debido
a la necesidad de procesar una secuencia de datos. Aunque las entradas y salidas textua-
les simples pueden modelarse de esta forma, las interfaces gr√°ficas de usuario tienen
formatos I/O m√°s complejos, as√≠ como una estrategia de control que se basa en eventos
como clics del mouse o selecciones del men√∫. Es dif√≠cil traducir esto en una forma com-
patible con el modelo pipelining

> Los sistemas de aplicaci√≥n tienen la intenci√≥n de cubrir las necesidades de una empresa u
organizaci√≥n.

> Estos factores en com√∫n condujeron al desarrollo de arquitecturas de software que
describen la estructura y la organizaci√≥n de tipos particulares de sistemas de software.
Las arquitecturas de aplicaci√≥n encapsulan las principales caracter√≠sticas de una clase de
sistemas

> Como dise√±ador de software, usted puede usar modelos de arquitecturas de aplicaci√≥n
en varias formas:
1. Como punto de partida para el proceso de dise√±o arquitect√≥nico Si no est√° fami-
liarizado con el tipo de aplicaci√≥n que desarrolla, podr√≠a basar su dise√±o inicial en una
arquitectura de aplicaci√≥n gen√©rica.

> 2. Como lista de verificaci√≥n del dise√±o Si usted desarroll√≥ un dise√±o arquitect√≥nico
para un sistema de aplicaci√≥n, puede comparar √©ste con la arquitectura de aplicaci√≥n
gen√©rica y luego, verificar que su dise√±o sea consistente con la arquitectura gen√©rica

> 3. Como una forma de organizar el trabajo del equipo de desarrollo Las arquitectu-
ras de aplicaci√≥n identifican caracter√≠sticas estructurales estables de las arquitecturas
del sistema y, en muchos casos, es posible desarrollar √©stas en paralelo

> 4. Como un medio para valorar los componentes a reutilizar Si tiene componen-
tes por reutilizar, compare √©stos con las estructuras gen√©ricas para saber si existen
componentes similares en la arquitectura de aplicaci√≥n

> 5. Como un vocabulario para hablar acerca de los tipos de aplicaciones Si discute
acerca de una aplicaci√≥n espec√≠fica o trata de comparar aplicaciones del mismo tipo,
entonces puede usar los conceptos identificados en la arquitectura gen√©rica para
hablar sobre las aplicaciones

> Los sistemas de procesamiento de transacciones (TP, por las siglas de Transaction Pro-
cessing) est√°n dise√±ados para procesar peticiones del usuario mediante la informaci√≥n de
una base de datos, o los requerimientos para actualizar una base de datos (

> Los sistemas de procesamiento de transacci√≥n pueden organizarse como una arqui-
tectura ‚Äútuber√≠a y filtro‚Äù con componentes de sistema responsables de entradas, proce-
samiento y salida

> Todos los sistemas que incluyen interacci√≥n con una base de datos compartida se con-
sideran sistemas de informaci√≥n basados en transacciones. Un sistema de informaci√≥n
permite acceso controlado a una gran base de informaci√≥n, tales como un cat√°logo de
biblioteca, un horario de vuelos o los registros de pacientes en un hospital. Cada vez m√°s,
los sistemas de informaci√≥n son sistemas basados en la Web, cuyo acceso es mediante
un navegador Web.

> El uso de m√∫ltiples servidores permite un rendimiento elevado, al igual que posibilita
la manipulaci√≥n de cientos de transacciones por minuto. Conforme aumenta la demanda,
pueden agregarse servidores en cada nivel, para lidiar con el procesamiento adicional
implicado.

> Los sistemas de procesamiento de lenguaje convierten un lenguaje natural o artificial en otra
representaci√≥n del lenguaje y, para lenguajes de programaci√≥n, tambi√©n pueden ejecutar el
c√≥digo resultante

> Los compiladores de lenguaje de programaci√≥n que forman parte de un entorno de
programaci√≥n m√°s general tienen una arquitectura gen√©rica (figura 6.19) que incluye los
siguientes componentes:
1. Un analizador l√©xico, que toma valores simb√≥licos (tokens) y los convierte en una
forma interna.
2. Una tabla de s√≠mbolos, que contiene informaci√≥n de los nombres de las entidades
(variables, de clase, de objeto, etc√©tera) usados en el texto que se traduce.
3. Un analizador de sintaxis, el cual verifica la sintaxis del lenguaje que se va a tradu-
cir. Emplea una gram√°tica definida del lenguaje y construye un √°rbol de sintaxis.
4. Un √°rbol de sintaxis es una estructura interna que representa el programa a compilar

> 5. Un analizador sem√°ntico que usa informaci√≥n del √°rbol de sintaxis y la tabla de s√≠m-
bolos, para verificar la exactitud sem√°ntica del texto en lenguaje de entrada.
6. Un generador de c√≥digo que ‚Äúrecorre‚Äù el √°rbol de sintaxis y genera un c√≥digo de
m√°quina abstracto.

> Una arquitectura de software es una descripci√≥n de c√≥mo se organiza un sistema de software.
Las propiedades de un sistema, como rendimiento, seguridad y disponibilidad, est√°n influidas
por la arquitectura utilizada.
‚ñ† Las decisiones de dise√±o arquitect√≥nico incluyen decisiones sobre el tipo de aplicaci√≥n, la
distribuci√≥n del sistema, los estilos arquitect√≥nicos a usar y las formas en que la arquitectura
debe documentarse y evaluarse.
‚ñ† Las arquitecturas pueden documentarse desde varias perspectivas o diferentes vistas. Las
posibles vistas incluyen la conceptual, la l√≥gica, la de proceso, la de desarrollo y la f√≠sica.
‚ñ† Los patrones arquitect√≥nicos son medios para reutilizar el conocimiento sobre las arquitecturas
de sistemas gen√©ricos. Describen la arquitectura, explican cu√°ndo debe usarse, y exponen sus
ventajas y desventajas.
‚ñ† Los patrones arquitect√≥nicos usados com√∫nmente incluyen el modelo de vista del controlador,
arquitectura en capas, repositorio, cliente-servidor, y tuber√≠a y filtro.
‚ñ† Los modelos gen√©ricos de las arquitecturas de sistemas de aplicaci√≥n ayudan a entender
la operaci√≥n de las aplicaciones, comparar aplicaciones del mismo tipo, validar dise√±os del
sistema de aplicaci√≥n y valorar componentes para reutilizaci√≥n a gran escala.
‚ñ† Los sistemas de procesamiento de transacci√≥n son sistemas interactivos que permiten el acceso
y la modificaci√≥n remota de la informaci√≥n, en una base de datos por parte de varios usuarios.
Los sistemas de informaci√≥n y los sistemas de gesti√≥n de recursos son ejemplos de sistemas de
procesamiento de transacciones.
‚ñ† Los sistemas de procesamiento de lenguaje se usan para traducir textos de un lenguaje a otro y
para realizar las instrucciones especificadas en el lenguaje de entrada. Incluyen un traductor y
una m√°quina abstracta que ejecuta el lenguaje generado.
Analizador
de sintaxis
Analizador
l√©xico
Analizador
sem√°ntico
√Årbol
de sintaxis
abstracto
Definici√≥n
gramatical
Tabla
de s√≠mbolos
Definici√≥n
de salida
Impresi√≥n
est√©tica
Editor
Optimizador
Generador
de c√≥digo
Repositorio
Figura 6.20 Arquitectura
de repositorio para
un sistema de
procesamiento de
lenguaje

> Un modelo es una visi√≥n abstracta de un sistema que ignora algunos detalles del sistema.
Pueden desarrollarse modelos complementarios del sistema para mostrar el contexto,
las interacciones, la estructura y el comportamiento del sistema.
‚ñ† Los modelos de contexto muestran c√≥mo un sistema a modelar se coloca en un entorno
con otros sistemas y procesos. Ayudan a definir las fronteras del sistema a desarrollar.
‚ñ† Los diagramas de caso de uso y los diagramas de secuencia se emplean para describir las
interacciones entre usuario/sistema a dise√±ar y usuarios/otros sistemas. Los casos de uso
describen interacciones entre un sistema y actores externos; los diagramas de secuencia
agregan m√°s informaci√≥n a √©stos al mostrar las interacciones entre objetos del sistema.

> Los modelos estructurales indican la organizaci√≥n y arquitectura de un sistema. Los diagramas
de clase se usan para definir la estructura est√°tica de clases en un sistema y sus asociaciones.
‚ñ† Los modelos del comportamiento se usan para describir la conducta din√°mica de un sistema
en ejecuci√≥n. Pueden modelarse desde la perspectiva de los datos procesados por el sistema,
o mediante los eventos que estimulan respuestas de un sistema.
‚ñ† Los diagramas de actividad se utilizan para modelar el procesamiento de datos, en que cada
actividad representa un paso del proceso.
‚ñ† Los diagramas de estado se utilizan para modelar el comportamiento de un sistema en
respuesta a eventos internos o externos.
‚ñ† La ingenier√≠a dirigida por modelo es un enfoque al desarrollo del software donde un sistema se
representa como un conjunto de modelos que pueden transformarse autom√°ticamente a c√≥digo
ejecutable

> Separa presentaci√≥n e interacci√≥n de los datos del sistema. El sistema se estructura en
tres componentes l√≥gicos que interact√∫an entre s√≠. El componente Modelo maneja los
datos del sistema y las operaciones asociadas a esos datos. El componente Vista define
y gestiona c√≥mo se presentan los datos al usuario. El componente Controlador dirige la
interacci√≥n del usuario

> Organiza el sistema en capas con funcionalidad relacionada con cada capa. Una capa
da servicios a la capa de encima, de modo que las capas de nivel inferior representan
servicios n√∫cleo que es probable se utilicen a lo largo de todo el sistema

> En una arquitectura cliente-servidor, la funcionalidad del sistema se organiza en servicios,
y cada servicio lo entrega un servidor independiente. Los clientes son usuarios de dichos
servicios y para utilizarlos ingresan a los servidores.

> El procesamiento de datos en un sistema se organiza de forma que cada componente de
procesamiento (filtro) sea discreto y realice un tipo de transformaci√≥n de datos. Los datos
fluyen (como en una tuber√≠a) de un componente a otro para su procesamiento
