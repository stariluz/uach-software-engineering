![Cover Image of chrome-extension://hldjnlbobkdkghfidgoecgmklcemanhm/pdf/web/viewer.html?file=file%3A%2F%2F%2FC%3A%2FUsers%2Fthead%2FDocuments%2FUACH%2FSeventh%2520Semester%2FSoftware%2520Engineering%2Fingdelsoftwarelibro9_compressed.pdf](https://web-highlights.com/images/fallback-image.png?auto=format&w=600&fm=auto)
  
# Ingenieria de Software - ingdelsoftwarelibro9_compressed.pdf


🌐 chrome-extension://hldjnlbobkdkghfidgoecgmklcemanhm/pdf/web/viewer.html?file=file%3A%2F%2F%2FC%3A%2FUsers%2Fthead%2FDocuments%2FUACH%2FSeventh%2520Semester%2FSoftware%2520Engineering%2Fingdelsoftwarelibro9_compressed.pdf
🔗 https://app.web-highlights.com/page/66f5f0972f2aaf23ca0ee9aa

**Tags**: -

**Highlights & Notes**

> ingeniería de requerimientos basada en un modelo, procesos de software
para desarrollo basado en un modelo, y pruebas basadas en un modelo son parte de MDE,
pero no, en este momento, de la MDA

> Esta visión de un sistema es adecuado particularmente para sistema en tiempo
real.

> l diseño arquitectónico como un conjunto de decisiones a tomar

> los patrones como una forma de presentar, compartir y reutilizar el conoci-
miento sobre los sistemas de software se usa ahora ampliamente.

> No siempre necesitará apegarse rigurosamente a los detalles de una notación.

> El mode-
lado de interacción del usuario es importante, pues ayuda a identificar los requerimientos
del usuario. El modelado de la interacción sistema a sistema destaca los problemas de
comunicación que se lleguen a presentar. El modelado de interacción de componentes
ayuda a entender si es probable que una estructura de un sistema propuesto obtenga el
rendimiento y la confiabilidad requeridos por el sistema

> ra
la mayoría de los sistemas, no vale la pena desarrollar una descripción arquitectónica
detallada desde estas cuatro perspectivas. Uno debe desarrollar las vistas que sean útiles
para la comunicación sin preocuparse si la documentación arquitectónica está completa
o no. Sin embargo, una excepción es al desarrollar sistemas críticos, cuando es necesario
realizar un análisis de confiabilidad detallado del sistema. Tal vez se deba convencer a
reguladores externos de que el sistema se hizo conforme a sus regulaciones y, en conse-
cuencia, puede requerirse una documentación arquitectónica completa

> patrón
de repositorio (figura 6.8), describe cómo comparte datos un conjunto de componentes
en interacción.

> Cada paso de
procesamiento se implementa como un transformador.

> Los datos fluyen
de uno a otro y se transforman conforme se desplazan a través de la secuencia

> Un caso de uso puede
tomarse como un simple escenario que describa lo que espera el usuario de un sistema.

> res formas en que los
modelos gráficos se emplean con frecuencia:
1. Como medio para facilitar la discusión sobre un sistema existente o propuesto.
2. Como una forma de documentar un sistema existente.
3. Como una descripción detallada del sistema que sirve para generar una implementa-
ción de sistema

> arquitecturas de dos
tipos de aplicación:
1. Aplicaciones de procesamiento de transacción Este tipo de aplicaciones son aplicacio-
nes centradas en bases de datos, que procesan los requerimientos del usuario mediante
la información y actualizan ésta en una base de datos. Se trata del tipo más común de
sistemas empresariales interactivos. Se organizan de tal forma que las acciones
del usuario no pueden interferir unas con otras y se mantiene la integridad de la base

> n una arquitectura
de compilador, la tabla de símbolos es un repositorio para datos compartidos. Las fases de
análisis léxico, sintáctico y semántico se organizan de manera secuencial, como se mues-
tra en la figura 6.19, y se comunican a través de la tabla de símbolos compartida.

> s necesario elegir
la estructura más adecuada, como cliente-servidor o estructura en capas, que le permita
satisfacer los requerimientos del sistema. Para descomponer las unidades del sistema
estructural, usted opta por la estrategia de separar los componentes en subcomponen-
tes. Los enfoques que pueden usarse permiten la implementación de diferentes tipos de
arquitectura. Finalmente, en el proceso de modelado de control, se toman decisiones
sobre cómo se controla la ejecución de componentes

> erspectiva estructural, donde se modelen la organización de un sistema o la
estructura de datos que procese el sistema

> Krutchen (1995), en
su bien conocido modelo de vista 4+1 de la arquitectura de software, sugiere que deben
existir cuatro vistas arquitectónicas fundamentales, que se relacionan usando casos de
uso o escenarios. Las vistas que él sugiere son:
1. Una vista lógica, que indique las abstracciones clave en el sistema como objetos o
clases de objeto. En este tipo de vista se tienen que relacionar los requerimientos del
sistema con entidades.

> buscar posibles traslapes en la funcionalidad con los sistemas existentes y determi-
nar dónde tiene que implementarse nueva funcionalidad. Estas decisiones deben hacerse
oportunamente durante el proceso, para limitar los costos del sistema, así como el tiempo
necesario para comprender los requerimientos y el diseño del sistema

> el diseño arquitectónico es la
primera etapa en el proceso de diseño del software. Es el enlace crucial entre el diseño y
la ingeniería de requerimientos, ya que identifica los principales componentes estructura-
les en un sistema y la relación entre ellos. La salida del proceso de diseño arquitectónico
consiste en un modelo arquitectónico que describe la forma en que se organiza el sistema
como un conjunto de componentes en comunicación

> El patrón de arquitectura en
capas es otra forma de lograr separación e independencia

> La descripción del patrón estilizado incluye el nombre del patrón, una breve des-
cripción (con un modelo gráfico asociado) y un ejemplo del tipo de sistema donde se usa
el patrón (de nuevo, quizá con un modelo gráfico). También debe incluir información
sobre cuándo hay que usar el patrón, así como sobre sus ventajas y desventajas. E

> uando los modelos se usan como
documentación, no tienen que estar completos, pues quizás usted sólo desee desarro-
llar modelos para algunas partes de un sistema. Sin embargo, estos modelos deben ser
correctos: tienen que usar adecuadamente la notación y ser una descripción precisa del
sistema.

> Es posible que los datos se pro-
cesen por cada transformador ítem por ítem o en un solo lote.

> El UML proporciona un tipo especial
de asociación entre clases llamado agregación, que significa que un objeto (el todo) se
compone de otros objetos (las partes). Para mostrarlo, se usa un trazo en forma de dia-
mante, junto con la clase que representa el todo.

> A partir de un modelo independiente
de plataforma de alto nivel, es posible, en principio, generar un programa funcional sin
intervención manual

> os diagramas de actividad inten-
tan mostrar las actividades que incluyen un proceso de sistema, así como el flujo de
control de una actividad a otra. El inicio de un proceso se indica con un círculo lleno;
el fin, mediante un círculo lleno dentro de otro círculo. Los rectángulos con esquinas
redondeadas representan actividades, esto es, los subprocesos específicos que hay que
realizar. Puede incluir objetos en los gráficos de actividad.

> Cuando las transformaciones son
secuenciales, con datos procesados en lotes, este modelo arquitectónico de tubería y fil-
tro se convierte en un modelo secuencial en lote, una arquitectura común para sistemas
de procesamiento de datos

> perspectiva externa, donde se modelen el contexto o entorno del sistema

> perspectiva de interacción, donde se modele la interacción entre un sistema y su
entorno, o entre los componentes de un sistema

> aplicaciones en las que un componente genere datos y otro los use. L

> es un modelo de la organización en tiempo de operación de un sistema, donde las
transformaciones funcionales procesan sus entradas y producen salidas

> el patrón tubería y filtro

> entajas de diseñar y documentar de
manera explícita la arquitectura de software:
1. Comunicación con los participantes La arquitectura es una presentación de alto
nivel del sistema, que puede usarse como un enfoque para la discusión de un amplio
número de participantes.
2. Análisis del sistema En una etapa temprana en el desarrollo del sistema, aclarar la
arquitectura del sistema requiere cierto análisis. Las decisiones de diseño arquitectó-
nico tienen un efecto profundo sobre si el sistema puede o no cubrir requerimientos
críticos como rendimiento, fiabilidad y mantenibilidad.
3. Reutilización a gran escala Un modelo de una arquitectura de sistema es una des-
cripción corta y manejable de cómo se organiza un sistema y cómo interoperan sus
componentes. Por lo general, la arquitectura del sistema es la misma para sistemas
con requerimientos similares y, por lo tanto, puede soportar reutilización de software
a gran escala.

> perspectiva de comportamiento, donde se modele el comportamiento dinámico
del sistema y cómo responde ante ciertos eventos

> se crean cuando se discute y diseña la arqui-
tectura del sistema. El diseño arquitectónico es un tema particularmente importante en la
ingeniería de software, y los diagramas UML de componente, de paquete y de implemen-
tación se utilizan cuando se presentan modelos arquitectónicos.

> Es posible hacer enunciados generales que se
apliquen a todos los miembros de la clase

> Cuando se desarrolla un modelo, la primera etapa con frecuencia implica buscar en
el mundo, identificar los objetos esenciales y representarlos como clases. La forma más
sencilla de hacer esto es escribir el nombre de la clase en un recuadro. También puede
anotar la existencia de una asociación dibujando simplemente una línea entre las clases.
Análisis de requerimientos orientado a objetos
En el análisis de requerimientos orientado a objetos, se modelan entidades del mundo real usando clases
de objetos. Usted puede crear diferentes tipos de modelos de objetos, que muestren cómo se relacionan
mutuamente las clases de objetos, cómo se agregan objetos para formar otros objetos, cómo interactúan los
objetos entre sí, etcétera. Cada uno de éstos presenta información única acerca del sistema que se especifica.
http://www.SoftwareEngineering-9.com/Web/OORA/

> el sistema Unix original, donde era posible
vincular procesos empleando “tuberías”

> La notación con figura humana se desarrolló original-
mente para cubrir la interacción entre individuos, pero también se usa ahora para repre-
sentar otros sistemas externos y el hardware. De manera formal, los diagramas de caso de
uso deben emplear líneas sin flechas; las flechas en el UML indican la dirección del flujo
de mensajes. Evidentemente, en un caso de uso los mensajes pasan en ambas direcciones

> Cada recuadro en el diagrama representa un com-
ponente. Los recuadros dentro de recuadros indican que el componente se dividió en
subcomponentes. Las flechas significan que los datos y/o señales de control pasan de
un componente a otro en la dirección de las flechas.

> onforme se desarrolla una implementación, por lo general
se necesitan definir los objetos de implementación adicionales que se usan para dar la
funcionalidad requerida del sistema. Aquí, el enfoque está sobre el modelado de objetos
del mundo real, como parte de los requerimientos o los primeros procesos de diseño del
software.

> a generalización se muestra como una flecha que apunta
hacia la clase más general.

> Sin embargo, se considera que la MDE tiene un ámbito más
amplio que la MDA. Como se estudia más adelante en esta sección, la MDA se enfoca en
las etapas de diseño e implementación del desarrollo de software, mientras que la MDE
se interesa por todos los aspectos del proceso de ingeniería de software.

> Una forma de hacer esto es mediante la noción de un superestado
que encapsule algunos estados separados. Este superestado se parece a un solo estado en
un modelo de nivel superior, pero entonces se expande para mostrar más detalles en un
diagrama separad

> soporta el desarrollo incremental de sistemas. Conforme se
desarrolla una capa, algunos de los servicios proporcionados por esta capa deben quedar
a disposición de los usuarios. La arquitectura también es cambiable y portátil. En tanto
su interfaz no varíe, una capa puede sustituirse por otra equivalente. Más aún, cuando
las interfaces de capa cambian o se agregan nuevas facilidades a una capa, sólo resulta
afectada la capa adyacente

> vista conceptual. Esta última es una vista abstracta del sistema que
puede ser la base para descomponer los requerimientos de alto nivel en especificaciones
más detalladas, ayudar a los ingenieros a tomar decisiones sobre componentes que pue-
dan reutilizarse, y representar una línea de producto

> Un patrón arquitectónico es una descripción de una organización del
sistema

> Se usa el término “filtro” porque una transformación “filtra” los
datos que puede procesar de su secuencia de datos de entrada

> la funcionalidad del sistema está organizada en capas separadas, y cada
una se apoya sólo en las facilidades y los servicios ofrecidos por la capa inmediatamente
debajo de ella

> un patrón arquitectónico debe describir una organización de sistema que
ha tenido éxito en sistemas previos. Debe incluir información sobre cuándo es y cuándo
no es adecuado usar dicho patrón, así como sobre las fortalezas y debilidades del patrón

> Los patrones arquitectónicos captan la esencia de una arquitectura que se usó
en diferentes sistemas de software

> . Sistemas de procesamiento de lenguaje Son sistemas en los que las intenciones del
usuario se expresan en un lenguaje formal (como Java). El sistema de procesamiento
de lenguaje elabora este lenguaje en un formato interno y después interpreta dicha
representación interna. Los sistemas de procesamiento de lenguaje mejor conocidos
son los compiladores, que traducen los programas en lenguaje de alto nivel dentro de
un código de máquina. Sin embargo, los sistemas de procesamiento de lenguaje se usan
también en la interpretación de lenguajes de comandos para bases de datos y sistemas
de información, así como de lenguajes de marcado como XML

> 1. Diagramas de actividad, que muestran las actividades incluidas en un proceso o en
el procesamiento de datos.
2. Diagramas de caso de uso, que exponen las interacciones entre un sistema y su
entorno.
3. Diagramas de secuencias, que muestran las interacciones entre los actores y el sis-
tema, y entre los componentes del sistema.
4. Diagramas de clase, que revelan las clases de objeto en el sistema y las asociaciones
entre estas clases.
5. Diagramas de estado, que explican cómo reacciona el sistema frente a eventos inter-
nos y externos.

> La definición de frontera de un sistema no es un juicio libre de valor. Las preocupa-
ciones sociales y organizacionales pueden significar que la posición de la frontera de un
sistema se determine considerando factores no técnicos. Por ejemplo, una frontera
de sistema puede colocarse deliberadamente, de modo que todo el proceso de análisis se
realice en un sitio; puede elegirse de forma que sea innecesario consultar a un adminis-
trador particularmente difícil; puede situarse de manera que el costo del sistema aumente
y la división de desarrollo del sistema deba, por lo tanto, expandirse al diseño y la imple-
mentación del sistema

> Los modelos de contexto, por lo general, muestran que el entorno incluye varios
sistemas automatizados. Sin embargo, no presentan los tipos de relaciones entre los sis-
temas en el entorno y el sistema que se especifica. Los sistemas externos generan datos
para el sistema o consumen datos del sistema. Pueden compartir datos con el sistema,
conectarse directamente, a través de una red, o no conectarse en absoluto. Pueden estar
físicamente juntos o ubicados en edificios separados. Todas estas relaciones llegan a
afectar los requerimientos y el diseño del sistema a definir, por lo que deben tomarse en
cuenta.
Por consiguiente, los modelos de contexto simples se usan junto con otros modelos,
como los modelos de proceso empresarial. Éstos describen procesos humanos y automa-
tizados que se usan en sistemas particulares de software

> En un diagrama de actividad UML, las flechas representan el flujo de trabajo de una acti-
vidad a otra. Una barra sólida se emplea para indicar coordinación de actividades. Cuando
el flujo de más de una actividad se dirige a una barra sólida, entonces todas esas actividades
deben completarse antes del posible avance. Cuando el flujo de una barra sólida conduzca
a algunas actividades, éstas pueden ejecutarse en forma paralela.

> 1. Modelado de caso de uso, que se utiliza principalmente para modelar interacciones
entre un sistema y actores externos (usuarios u otros sistemas).
2. Diagramas de secuencia, que se emplean para modelar interacciones entre compo-
nentes del sistema, aunque también pueden incluirse agentes externos.

> Cada caso de uso representa una tarea discreta que implica interacción externa con
un sistema. En su forma más simple, un caso de uso se muestra como una elipse, con los
actores que intervienen en el caso de uso representados como figuras humanas

> Los diagramas de secuencia en el UML se usan principalmente para modelar las interaccio-
nes entre los actores y los objetos en un sistema, así como las interacciones entre los obje-
tos en sí. El UML tiene una amplia sintaxis para diagramas de secuencia, lo cual permite
muchos tipos diferentes de interacción a modelar.

> Como sugiere el nombre, un diagrama de secuencia muestra la sucesión de interaccio-
nes que ocurre durante un caso de uso particular o una instancia de caso de uso.

> Los objetos y actores que intervienen se mencionan a lo largo de la parte superior del
diagrama, con una línea punteada que se dibuja verticalmente a partir de éstos. Las inte-
racciones entre los objetos se indican con flechas dirigidas. El rectángulo sobre las líneas
punteadas indica la línea de vida del objeto tratado (es decir, el tiempo que la instancia
del objeto está involucrada en la computación). La secuencia de interacciones se lee de
arriba abajo. Las anotaciones sobre las flechas señalan las llamadas a los objetos, sus
parámetros y los valores que regresan. En este ejemplo, también se muestra la notación
empleada para exponer alternativas. Un recuadro marcado con “alt” se usa con las condi-
ciones indicadas entre corchetes.

> A menos que use diagramas de secuencia para generación de código o documen-
tación detallada, en dichos diagramas no tiene que incluir todas las interacciones. Si
desarrolla modelos iniciales de sistema en el proceso de desarrollo para apoyar la ingenie-
ría de requerimientos y el diseño de alto nivel, habrá muchas interacciones que dependan
de decisiones de implementación.

> Los modelos estructurales de software muestran la organización de un sistema, en tér-
minos de los componentes que constituyen dicho sistema y sus relaciones. Los modelos
estructurales son modelos estáticos, que muestran la estructura del diseño del sistema, o
modelos dinámicos, que revelan la organización del sistema cuando se ejecuta. No son lo
mismo: la organización dinámica de un sistema como un conjunto de hilos en interacción
tiende a ser muy diferente de un modelo estático de componentes del sistema

> Los diagramas de clase pueden usarse cuando se desarrolla un modelo de sistema orien-
tado a objetos para mostrar las clases en un sistema y las asociaciones entre dichas clases.
De manera holgada, una clase de objeto se considera como una definición general de un
tipo de objeto del sistema. Una asociación es un vínculo entre clases, que indica que hay
una relación entre dicha clases. En consecuencia, cada clase puede tener algún conoci-
miento de esta clase asociada.

> En este nivel de detalle, los diagramas de clase parecen modelos semánticos de datos.
Los modelos semánticos de datos se usan en el diseño de bases de datos. Muestran las
entidades de datos, sus atributos asociados y las relaciones entre dichas entidades. Es

> Cuando se muestran las asociaciones entre clases, es conveniente representar dichas
clases en la forma más sencilla posible. Para definirlas con más detalle, agregue infor-
mación sobre sus atributos (las características de un objeto) y operaciones (aquello que
se puede solicitar de un objeto)

> 1. El nombre de la clase de objeto está en la sección superior.
2. Los atributos de clase están en la sección media. Esto debe incluir los nombres del
atributo y, opcionalmente, sus tipos.
3. Las operaciones (llamadas métodos en Java y en otros lenguajes de programación
OO) asociadas con la clase de objeto están en la sección inferior del rectángulo.

> La generalización es una técnica cotidiana que se usa para gestionar la complejidad.
En vez de aprender las características detalladas de cada entidad que se experimenta,
dichas entidades se colocan en clases más generales

> En el modelado de sistemas, con frecuencia es útil examinar las clases en un sistema,
con la finalidad de ver si hay ámbito para la generalización. Esto significa que la infor-
mación común se mantendrá solamente en un lugar. Ésta es una buena práctica de diseño,
pues significa que, si se proponen cambios, entonces no se tiene que buscar en todas las
clases en el sistema, para observar si se ven afectadas por el cambio. En los lenguajes
orientados a objetos, como Java, la generalización se implementa usando los mecanis-
mos de herencia de clase construidos en el lenguaje

> En una generalización, los atributos y las operaciones asociados con las clases de
nivel superior también se asocian con las clases de nivel inferior. En esencia, las cla-
ses de nivel inferior son subclases que heredan los atributos y las operaciones de sus
superclases. Entonces dichas clases de nivel inferior agregan atributos y operaciones
más específicos.

> Los modelos de comportamiento son modelos dinámicos del sistema conforme se eje-
cutan. En ellos se muestra lo que sucede o lo que se supone que pasa cuando un sistema
responde ante un estímulo de su entorno. Tales estímulos son de dos tipos:
1. Datos Algunos datos que llegan se procesan por el sistema.
2. Eventos Algunos eventos activan el procesamiento del sistema. Los eventos pueden
tener datos asociados, pero esto no es siempre el caso.

> Los modelos dirigidos por datos muestran la secuencia de acciones involucradas en
el procesamiento de datos de entrada, así como la generación de una salida asociada.
Son particularmente útiles durante el análisis de requerimientos, pues sirven para mostrar
procesamiento “extremo a extremo” en un sistema. Esto es, exhiben toda la secuencia de
acciones que ocurren desde una entrada a procesar hasta la salida correspondiente, que es
la respuesta del sistema

> El UML no soporta diagramas de flujo de datos, puesto que originalmente se propusie-
ron y usaron para modelar el procesamiento de datos. La razón para esto es que los DFD
se enfocan en funciones del sistema y no reconocen objetos del sistema. S

> El modelado dirigido por un evento muestra cómo responde un sistema a eventos exter-
nos e internos. Se basa en la suposición de que un sistema tiene un número finito de
estados y que los eventos (estímulos) pueden causar una transición de un estado a otro.

> El UML soporta modelado basado en eventos usando diagramas de estado, que se fun-
damentaron en gráficos de estado (Harel, 1987, 1988). Los diagramas de estado muestran
estados y eventos del sistema que causan transiciones de un estado a otro

> En los diagramas de estado UML, los rectángulos redondeados representan estados
del sistema. Pueden incluir una breve descripción (después de “do”) de las acciones que
se tomarán en dicho estado. Las flechas etiquetadas representan estímulos que fuerzan
una transición de un estado a otro. Puede indicar los estados inicial y final usando círcu-
los rellenos, como en los diagramas de actividad

> La notación UML permite indicar la actividad que ocurre en un estado. En una especifi-
cación detallada del sistema, hay que proporcionar más detalle tanto de los estímulos como
de los estados del sistema

> El problema con el modelado basado en el estado es que el número de posibles estados
se incrementa rápidamente

> La ingeniería dirigida por modelo (MDE, por las siglas de Model-Driven Engineering) es
un enfoque al desarrollo de software donde los modelos, y no los programas, son las sali-
das principales del proceso de desarrollo (

> La ingeniería basada en modelo permite a los ingenieros pen-
sar sobre sistemas en un nivel de abstracción elevado, sin ocuparse por los deta-
lles de su implementación. Esto reduce la probabilidad de errores, acelera el diseño
y el proceso de implementación, y permite la creación de modelos de aplicación
reutilizables, independientes de la plataforma de aplicación. A

> no siempre se sigue que las abstracciones que soporta el modelo son las abstrac-
ciones correctas para la implementación. De este modo, es posible crear modelos
de diseño informal, pero siendo así, el sistema se implementa usando un paquete
configurable comercial

> La arquitectura dirigida por modelo (Kleppe et al., 2003; Mellor et al., 2004; Stahl y
Voelter, 2006) es un enfoque orientado a un modelos para el diseño y la implementación
de software, que usa un subconjunto de modelos UML para describir un sistem

> El método de MDA recomienda la producción de tres tipos de modelo de sistema
abstracto:
1. Un modelo independiente de computación (CIM) que modela las importantes abs-
tracciones de dominio usadas en el sistema

> 2. Un modelo independiente de plataforma (PIM) que modele la operación del sistema
sin referencia a su implementación. El PIM se describe usualmente mediante mode-
los UML que muestran la estructura estática del sistema y cómo responde a eventos
externos e internos

> 3. Modelos específicos de plataforma (PSM) que son transformaciones del modelo
independiente de plataforma con un PSM separado para cada plataforma de apli-
cación. En principio, puede haber capas de PSM, y cada una agrega cierto detalle
específico de la plataforma. De este modo, el PSM de primer nivel podría ser específi-
co de “middleware”, pero independiente de la base de datos. Cuando se elige una base
de datos específica, podría generarse entonces un PSM específico de base de datos

> La noción fundamental detrás de la ingeniería dirigida por modelo es que debe ser posible
la transformación completamente automatizada de modelos a código. Para lograr esto,
usted tiene que ser capaz de construir modelos gráficos, cuya semántica esté bien defi-
nida. También necesita una forma de agregar a los modelos gráficos, información sobre
la forma en que se implementan las operaciones definidas en el modelo.

> El diseño arquitectónico se interesa por entender cómo debe organizarse un sistema y
cómo tiene que diseñarse la estructura global de ese sistema.

> En la práctica, hay un significativo traslape entre los procesos de ingeniería de reque-
rimientos y el diseño arquitectónico. De manera ideal, una especificación de sistema no
debe incluir cierta información de diseño. Esto no es realista, excepto para sistemas muy
pequeños. La descomposición arquitectónica es por lo general necesaria para estructurar
y organizar la especificación. Por lo tanto, como parte del proceso de ingeniería de reque-
rimientos, usted podría proponer una arquitectura de sistema abstracta donde se asocien
grupos de funciones de sistemas o características con componentes o subsistemas a gran
escala. Luego, puede usar esta descomposición para discutir con los participantes sobre
los requerimientos y las características del sistema

> 1. La arquitectura en pequeño se interesa por la arquitectura de programas individua-
les. En este nivel, uno se preocupa por la forma en que el programa individual se
separa en componentes. Este capítulo se centra principalmente en arquitecturas de
programa.
2. La arquitectura en grande se interesa por la arquitectura de sistemas empresaria-
les complejos que incluyen otros sistemas, programas y componentes de programa.

> Las arquitecturas de sistemas se modelan con frecuencia usando diagramas de blo-
ques simples

> hay dos formas en que se utiliza un modelo arquitectónico de un programa:
1. Como una forma de facilitar la discusión acerca del diseño del sistema

> 2. Como una forma de documentar una arquitectura que se haya diseñado

> El diseño arquitectónico es un proceso creativo en el cual se diseña una organización
del sistema que cubrirá los requerimientos funcionales y no funcionales de éste.

> 1. ¿Existe alguna arquitectura de aplicación genérica que actúe como plantilla para el
sistema que se está diseñando?
2. ¿Cómo se distribuirá el sistema a través de algunos núcleos o procesadores?
3. ¿Qué patrones o estilos arquitectónicos pueden usarse?
4. ¿Cuál será el enfoque fundamental usado para estructurar el sistema?
5. ¿Cómo los componentes estructurales en el sistema se separarán en subcomponentes?
6. ¿Qué estrategia se usará para controlar la operación de los componentes en el
sistema?
7. ¿Cuál organización arquitectónica es mejor para entregar los requerimientos no fun-
cionales del sistema?
8. ¿Cómo se evaluará el diseño arquitectónico?
9. ¿Cómo se documentará la arquitectura del sistema?

> 1. Rendimiento Si el rendimiento es un requerimiento crítico, la arquitectura debe
diseñarse para localizar operaciones críticas dentro de un pequeño número de com-
ponentes, con todos estos componentes desplegados en la misma computadora en vez
de distribuirlos por la red

> 2. Seguridad Si la seguridad es un requerimiento crítico, será necesario usar una
estructura en capas para la arquitectura, con los activos más críticos protegidos en
las capas más internas, y con un alto nivel de validación de seguridad aplicado a
dichas capas.

> 3. Protección Si la protección es un requerimiento crítico, la arquitectura debe dise-
ñarse de modo que las operaciones relacionadas con la protección se ubiquen en algún
componente individual o en un pequeño número de componentes.

> 4. Disponibilidad Si la disponibilidad es un requerimiento crítico, la arquitectura tiene
que diseñarse para incluir componentes redundantes de manera que sea posible sus-
tituir y actualizar componentes sin detener el sistema.

> 5. Mantenibilidad Si la mantenibilidad es un requerimiento crítico, la arquitectura
del sistema debe diseñarse usando componentes autocontenidos de grano fino q

> 2. Una vista de proceso, que muestre cómo, en el tiempo de operación, el sistema está
compuesto de procesos en interacción.

> 3. Una vista de desarrollo, que muestre cómo el software está descompuesto para
su desarrollo, esto es, indica la descomposición del software en elementos que se
implementen mediante un solo desarrollador o equipo de desarrollo.

> 4. Una vista física, que exponga el hardware del sistema y cómo los componentes de
software se distribuyen a través de los procesadores en el sistema.

> Un patrón arquitectónico se puede considerar como una descripción abstracta estili-
zada de buena práctica, que se ensayó y puso a prueba en diferentes sistemas y entornos

> Las nociones de separación e independencia son fundamentales para el diseño arquitec-
tónico porque permiten localizar cambios.

> La mayoría de los sistemas que usan grandes cantidades de datos se organizan sobre
una base de datos o un repositorio compartido.

> Un sistema que sigue el patrón cliente-servidor se organiza como un conjunto de ser-
vicios y servidores asociados, y de clientes que acceden y usan los servicios. Los princi-
pales componentes de este modelo son:
1. Un conjunto de servidores que ofrecen servicios a otros componentes.

> 2. Un conjunto de clientes que solicitan los servicios que ofrecen los servidores

> 3. Una red que permite a los clientes acceder a dichos servicios

> Las arquitecturas cliente-servidor se consideran a menudo como arquitecturas de sis-
temas distribuidos; sin embargo, el modelo lógico de servicios independientes que opera
en servidores separados puede implementarse en una sola computadora.

> Es posible que los clientes deban conocer los nombres de los servidores disponibles,
así como los servicios que proporcionan. Sin embargo, los servidores no necesitan cono-
cer la identidad de los clientes o cuántos clientes acceden a sus servicios. L

> Los sistemas interactivos son difíciles de escribir con el modelo tubería y filtro, debido
a la necesidad de procesar una secuencia de datos. Aunque las entradas y salidas textua-
les simples pueden modelarse de esta forma, las interfaces gráficas de usuario tienen
formatos I/O más complejos, así como una estrategia de control que se basa en eventos
como clics del mouse o selecciones del menú. Es difícil traducir esto en una forma com-
patible con el modelo pipelining

> Los sistemas de aplicación tienen la intención de cubrir las necesidades de una empresa u
organización.

> Estos factores en común condujeron al desarrollo de arquitecturas de software que
describen la estructura y la organización de tipos particulares de sistemas de software.
Las arquitecturas de aplicación encapsulan las principales características de una clase de
sistemas

> Como diseñador de software, usted puede usar modelos de arquitecturas de aplicación
en varias formas:
1. Como punto de partida para el proceso de diseño arquitectónico Si no está fami-
liarizado con el tipo de aplicación que desarrolla, podría basar su diseño inicial en una
arquitectura de aplicación genérica.

> 2. Como lista de verificación del diseño Si usted desarrolló un diseño arquitectónico
para un sistema de aplicación, puede comparar éste con la arquitectura de aplicación
genérica y luego, verificar que su diseño sea consistente con la arquitectura genérica

> 3. Como una forma de organizar el trabajo del equipo de desarrollo Las arquitectu-
ras de aplicación identifican características estructurales estables de las arquitecturas
del sistema y, en muchos casos, es posible desarrollar éstas en paralelo

> 4. Como un medio para valorar los componentes a reutilizar Si tiene componen-
tes por reutilizar, compare éstos con las estructuras genéricas para saber si existen
componentes similares en la arquitectura de aplicación

> 5. Como un vocabulario para hablar acerca de los tipos de aplicaciones Si discute
acerca de una aplicación específica o trata de comparar aplicaciones del mismo tipo,
entonces puede usar los conceptos identificados en la arquitectura genérica para
hablar sobre las aplicaciones

> Los sistemas de procesamiento de transacciones (TP, por las siglas de Transaction Pro-
cessing) están diseñados para procesar peticiones del usuario mediante la información de
una base de datos, o los requerimientos para actualizar una base de datos (

> Los sistemas de procesamiento de transacción pueden organizarse como una arqui-
tectura “tubería y filtro” con componentes de sistema responsables de entradas, proce-
samiento y salida

> Todos los sistemas que incluyen interacción con una base de datos compartida se con-
sideran sistemas de información basados en transacciones. Un sistema de información
permite acceso controlado a una gran base de información, tales como un catálogo de
biblioteca, un horario de vuelos o los registros de pacientes en un hospital. Cada vez más,
los sistemas de información son sistemas basados en la Web, cuyo acceso es mediante
un navegador Web.

> El uso de múltiples servidores permite un rendimiento elevado, al igual que posibilita
la manipulación de cientos de transacciones por minuto. Conforme aumenta la demanda,
pueden agregarse servidores en cada nivel, para lidiar con el procesamiento adicional
implicado.

> Los sistemas de procesamiento de lenguaje convierten un lenguaje natural o artificial en otra
representación del lenguaje y, para lenguajes de programación, también pueden ejecutar el
código resultante

> Los compiladores de lenguaje de programación que forman parte de un entorno de
programación más general tienen una arquitectura genérica (figura 6.19) que incluye los
siguientes componentes:
1. Un analizador léxico, que toma valores simbólicos (tokens) y los convierte en una
forma interna.
2. Una tabla de símbolos, que contiene información de los nombres de las entidades
(variables, de clase, de objeto, etcétera) usados en el texto que se traduce.
3. Un analizador de sintaxis, el cual verifica la sintaxis del lenguaje que se va a tradu-
cir. Emplea una gramática definida del lenguaje y construye un árbol de sintaxis.
4. Un árbol de sintaxis es una estructura interna que representa el programa a compilar

> 5. Un analizador semántico que usa información del árbol de sintaxis y la tabla de sím-
bolos, para verificar la exactitud semántica del texto en lenguaje de entrada.
6. Un generador de código que “recorre” el árbol de sintaxis y genera un código de
máquina abstracto.

> Una arquitectura de software es una descripción de cómo se organiza un sistema de software.
Las propiedades de un sistema, como rendimiento, seguridad y disponibilidad, están influidas
por la arquitectura utilizada.
■ Las decisiones de diseño arquitectónico incluyen decisiones sobre el tipo de aplicación, la
distribución del sistema, los estilos arquitectónicos a usar y las formas en que la arquitectura
debe documentarse y evaluarse.
■ Las arquitecturas pueden documentarse desde varias perspectivas o diferentes vistas. Las
posibles vistas incluyen la conceptual, la lógica, la de proceso, la de desarrollo y la física.
■ Los patrones arquitectónicos son medios para reutilizar el conocimiento sobre las arquitecturas
de sistemas genéricos. Describen la arquitectura, explican cuándo debe usarse, y exponen sus
ventajas y desventajas.
■ Los patrones arquitectónicos usados comúnmente incluyen el modelo de vista del controlador,
arquitectura en capas, repositorio, cliente-servidor, y tubería y filtro.
■ Los modelos genéricos de las arquitecturas de sistemas de aplicación ayudan a entender
la operación de las aplicaciones, comparar aplicaciones del mismo tipo, validar diseños del
sistema de aplicación y valorar componentes para reutilización a gran escala.
■ Los sistemas de procesamiento de transacción son sistemas interactivos que permiten el acceso
y la modificación remota de la información, en una base de datos por parte de varios usuarios.
Los sistemas de información y los sistemas de gestión de recursos son ejemplos de sistemas de
procesamiento de transacciones.
■ Los sistemas de procesamiento de lenguaje se usan para traducir textos de un lenguaje a otro y
para realizar las instrucciones especificadas en el lenguaje de entrada. Incluyen un traductor y
una máquina abstracta que ejecuta el lenguaje generado.
Analizador
de sintaxis
Analizador
léxico
Analizador
semántico
Árbol
de sintaxis
abstracto
Definición
gramatical
Tabla
de símbolos
Definición
de salida
Impresión
estética
Editor
Optimizador
Generador
de código
Repositorio
Figura 6.20 Arquitectura
de repositorio para
un sistema de
procesamiento de
lenguaje

> Un modelo es una visión abstracta de un sistema que ignora algunos detalles del sistema.
Pueden desarrollarse modelos complementarios del sistema para mostrar el contexto,
las interacciones, la estructura y el comportamiento del sistema.
■ Los modelos de contexto muestran cómo un sistema a modelar se coloca en un entorno
con otros sistemas y procesos. Ayudan a definir las fronteras del sistema a desarrollar.
■ Los diagramas de caso de uso y los diagramas de secuencia se emplean para describir las
interacciones entre usuario/sistema a diseñar y usuarios/otros sistemas. Los casos de uso
describen interacciones entre un sistema y actores externos; los diagramas de secuencia
agregan más información a éstos al mostrar las interacciones entre objetos del sistema.

> Los modelos estructurales indican la organización y arquitectura de un sistema. Los diagramas
de clase se usan para definir la estructura estática de clases en un sistema y sus asociaciones.
■ Los modelos del comportamiento se usan para describir la conducta dinámica de un sistema
en ejecución. Pueden modelarse desde la perspectiva de los datos procesados por el sistema,
o mediante los eventos que estimulan respuestas de un sistema.
■ Los diagramas de actividad se utilizan para modelar el procesamiento de datos, en que cada
actividad representa un paso del proceso.
■ Los diagramas de estado se utilizan para modelar el comportamiento de un sistema en
respuesta a eventos internos o externos.
■ La ingeniería dirigida por modelo es un enfoque al desarrollo del software donde un sistema se
representa como un conjunto de modelos que pueden transformarse automáticamente a código
ejecutable

> Separa presentación e interacción de los datos del sistema. El sistema se estructura en
tres componentes lógicos que interactúan entre sí. El componente Modelo maneja los
datos del sistema y las operaciones asociadas a esos datos. El componente Vista define
y gestiona cómo se presentan los datos al usuario. El componente Controlador dirige la
interacción del usuario

> Organiza el sistema en capas con funcionalidad relacionada con cada capa. Una capa
da servicios a la capa de encima, de modo que las capas de nivel inferior representan
servicios núcleo que es probable se utilicen a lo largo de todo el sistema

> En una arquitectura cliente-servidor, la funcionalidad del sistema se organiza en servicios,
y cada servicio lo entrega un servidor independiente. Los clientes son usuarios de dichos
servicios y para utilizarlos ingresan a los servidores.

> El procesamiento de datos en un sistema se organiza de forma que cada componente de
procesamiento (filtro) sea discreto y realice un tipo de transformación de datos. Los datos
fluyen (como en una tubería) de un componente a otro para su procesamiento
